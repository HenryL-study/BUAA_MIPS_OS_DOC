#### Lab3 实验报告

##### Thinking 3.1

因为取用env控制块时是用LIST_FIRST宏来取的，所以逆序插入的话取进程块时就是从头开始取。并且进程调度时由于是从0号进程开始调度，所以也需要逆序插入。

##### Thinking 3.2

1. 根据mmu.h里面的布局，我们采用的是2G/2G模式布局，所以对于不同的进程而言，其虚拟地址ULIM以上的地方，映射关系是相同的。因为这2G虚拟地址与物理地址的对应是由内核管理。所以可以直接使用boot_pgdir作为一部分模板。
2. UTOP区域以下我理解的是存放一个进程运行所必须的代码区，栈区，异常区以保持程序正常的运行。ULIM是一个用户进程所能正常访问虚拟地址最大值，UTOP-ULIM之间保存了虚拟地址到物理地址转换所需的页目录，页表以及其他进程的信息，在需要时可以及时访问。
3. env_cr3这个变量保存了该进程页目录的物理地址。根据4G页表的自映射机制，pgdir[UVPT >> 22] 即 pgdir[PDX(UVPT)]正好是该页目录的起点所在。

##### Thinking 3.3

user_data是一个回调函数的参数。不能没有这个参数，因为这样就无法把ELF文件内容与用户数据（这里是进程指针）联系起来。另外是一个空类型指针所以可以接受任何类型的指针，类似于面向对象的接口，可以自由设置要传入的值。

例：C语言 stdlib.h中的qsort函数

函数原型

```c
void qsort(void* base,size_t num,size_t width,int(__cdecl* compare)(const void*,const void*));
```

`void* base`可以自由设置数组的首地址，无论是int类型还是char类型还是其他类型，`int(__cdecl* compare)(const void*,const void*)`传入一个自定义的比较函数。功能和用法都和load_elf()函数极为相似。

##### Thinking 3.4

1. 虚拟空间
2. entry_point其值对于每个进程应该不一样，程序正常运行前应该会预加载一些数据以保证程序的运行。
3. 布局图是什么鬼？mmu.h那个？ 那应该是UTEXT = 0X00400000。

##### Thinking 3.5

env_tf.pc应该设置为cp0_epc的值，因为中断发生时epc保存当前pc的值（计组P7）。

##### Thinking 3.6

1. TIMESTACK为专门为时钟中断保存的栈，用以和其他类型的中断区分开来，便于管理调度可运行的进程。
2. mmh.h 中定义`define TIMESTACK 0x82000000` ，我们在env_run函数中看到每次运行时通过`env_pop_tf`从栈中取出对应的上下文恢复进程。
3. KERNEL_SP应该是保存当前可运行进程的栈，类似于一个登记。

##### Thinking 3.7

我认为这种绝对的平均调度可能会使得一些优先级较高的进程得不到及时的调度。

如果只运行两个进程，可以将所需运行时间较长或者优先级较高的进程在循环中每次多运行一次。就行lab3-exam。

##### 附：

我认为的难点：

3.1和3.4其实是比较懵逼的...主要是相关知识匮乏而且难以获取。

3.7也有点懵逼。

#### 实验难点

说实话，我觉得除了Exercise3.1和3.2以外，其他都是难点。有些函数没有说明可能要用到的其他函数。导致写的时候一脸懵逼。

`static int env_setup_vm (struct Env *e)`函数中最后两句话的理解比较困难。

而`load_ icode_ mapper`函数则是最为恶心。不知道需要用到什么函数，参数的解释模棱两可，几乎完全是根据JOS源码胡乱推倒。而其中的`offset`变量困扰了我整整一天。终究还是对于ELF文件不了解，如何加载到内存的过程不了解造成的。

其他的照葫芦画瓢基本能完成。但是比较难的是对于一堆汇编函数的理解。

#### 心得感想

由于OO和OS堆在了一周，所以瞬间爆炸BOOM！

连续两天晚上到4点半加一个上午终于是干完了。实验的难度还是很大。

调试的时候while(1)不甚管用了！！

于是又get了新方法，-t 查看函数调用情况。

不过OS实验还是比OO有意思多了。